/*!
    \page tetristutorial.html tutorial

    \title Tetris tutorial

    \brief This tutorial will show you how to develop a tetris game using V-Play Game Engine.

    \section2 How to Make a Tetris game with V-Play

    \image 00_finalResult.png

    \section1 About Tetris.
    Tetris is well known arcade game where you have to place falling object
    to fill lines.
    A filled line disappears and gives score.
    As game progress the speed increses and you have less time to think.
    Game is finished when the new object cannot fit into game board.

    \section1 Setting up
    - install V-Play SDK from \l {https://v-play.net/download/} {V-Play download page}.

    - launch Qt Creator
    \image 01_startQtCreator.png

    - choose File - New File or Project...  create Empty V-Play 2 Project
    \image 02_chooseProject.png

    \section1 Making gameboard and items
    The gameboard of Tetris is a grid of cells, where each cell can be empty or
    can have an Item in it.
    The Scene object which we already have in Main.qml is having by default
    \e {scaleMode} equal to \e {letterbox},
    which perfectly works for our case,
    when we need to maintain same ratio between height in widths on any screen resolutions.

    \section2 Adding basic cell
    First we need to create a basic item for all Tetris figures.
    This will be new QML type, which will be places in a separate file.
    Right-click on project name in Projects window and select Add New...
    V-Play provides you with some basic class types, we need a simple Item.
    It will be named Cell.
    Now lets change the basic element type from Item to Rectanle,
    as we need some graphics for our future cell.
    And change it's color property to red.
    Also we need some custom properties like cellX, cellY and cellSize.
    They will define cell position and size inside of gameboard. This is how it look in code
    \code
        property int cellSize: 20
        property int cellX: 0
        property int cellY: 0

        x: cellX * cellSize
        y: cellY * cellSize
        width: cellSize
        height: cellSize
    \endcode

    Lets add some Cell items to our \e {scene} after the \e {rectanle} object
    like this
    \code
        Cell {cellX: 0; cellY: 0}
        Cell {cellX: 0; cellY: 1}
        Cell {cellX: 1; cellY: 1}
        Cell {cellX: 1; cellY: 2}
    \endcode
    and we can see the result now.
    \image 03_firstImage.png

    \section2 Adding figure
    Now lets add Figure item, same as we added Cell item in \l {Adding basic cell}.

    In Tetris a Figure is a combination of 4 Cells.
    So lets move the Cell items from Scene to our Figure object.
    And dont forget to add Figure properties.
    \code
        property int cellSize: 20
        property int cellX: 0
        property int cellY: 0

        x: cellX * cellSize
        y: cellY * cellSize
    \endcode

    Now we can replace the Cell items from \e {scene} with one Figure,
    and try to move it to other position, like this
    \code
        Figure{
            id: figure
            cellX: 4
            cellY: 2
        }
    \endcode

    Also we can add to \e {scene} key press hadlers
    which will move our \e {figure} around:
    \code
        Keys.onLeftPressed:  figure.cellX--
        Keys.onRightPressed: figure.cellX++
        Keys.onUpPressed:    figure.cellY--
        Keys.onDownPressed:  figure.cellY++
    \endcode

    \section1 Lets add more relation and logic
    Now lets add more rules to our gameboard.
    We are going to have gameboard of size 16 x 24 cells.
    For our \e {scene} size of 320 x 480, this results in cell size equal with 20.
    Let add a property for this, which will be used by all figures.
    \code
        property int cellSize: 40
    \endcode
    And dont forget to add usage of it into Figure and Cells of Figure like this
    \code
        cellSize: scene.cellSize
    \endcode

    \section2 Action now!
    Finally lets add some life to the items we have.
    The first thing we need is a Timer. The properties we need
    is interval, it is how often it triggers, and the handler
    of trigger event. This will look like this initially:
    \code
        Timer {
            id: mainTimer
            interval: 1000
            repeat: true
            onTriggered: {
                console.debug("Hello world!")
            }
        }
    \endcode
    Also the timer is not started initially, so lets add this function
    to the MouseArea which already it presend in the scene:
    \code
        mainTimer.running = true
    \endcode

    \section2 More dynamics
    The figures now need to be dynamicaly created.
    For this we will add a function and a property to our scene object:
    \code
        property var figures: []
        ...
        function addFigure(){
            var component = Qt.createComponent("Figure.qml");
            if (component.status == Component.Ready) {
                var figure = component.createObject(scene);
                figure.cellX = 5
                figure.cellY = 0
            }
            scene.figures.push(figure)
        }
    \endcode
    This function will create a Figure object and will add them to scene
    list of figures. Also lets call this add Figure in MouseArea press handler,
    and the Timer handler now will move all scene figures down by one position.
    \code
        onTriggered: {
            for(var i=0; i<scene.figures.length; i++) {
                var figure = scene.figures[i]
                figure.cellY++
            }
        }
    \endcode

    After some clicking we can get this result
    \image 04_alotofFigures.png

    \section2 Stopping figures
    As figures reach the bottom side they need to stop and accululate.
    For this we will create a list of static Cells which we will get from
    Figures which rich the bottom line.

    First lets add bottom line detection in Timer trigger handler:
    \code
        for(i=0; i<scene.figures.length; i++) {
            figure = scene.figures[i]
            var isDown = false
            for(var j=0;j<figure.children.length;j++){
                cell = figure.children[j]
                if ( scene.isCellDown(cell) ) {
                    isDown = true
                    break;
                }
            }
            if ( isDown ) {
                scene.moveFigureToStatic(figure)
            }
        }
    \endcode

    For this we will need some more functions in our scene :
    \code
        function isCellDown(cell) {
            var cellY = cell.cellY
            var parentY = cell.parent.cellY
            return ((cellY + parentY + 1) == scene.gridHeigth)
        }
        ...
        function moveFigureToStatic(figure) {
            var index = scene.figures.indexOf(figure)
            scene.figures.splice(index, 1)

            for(var j=0;j<figure.children.length;j++){
                var cell = figure.children[j]
                scene.createStaticCellFrom(cell)
            }

            figure.destroy()
        }

        function createStaticCellFrom(oldcell){
            var component = Qt.createComponent("Cell.qml");
            if (component.status == Component.Ready) {
                var cell = component.createObject(scene);
                cell.cellX = oldcell.cellX + oldcell.parent.cellX
                cell.cellY = oldcell.cellY + oldcell.parent.cellY
                scene.cells.push(cell)
            }
        }
    \endcode
    First one is checking if cell is at the botton of scene.
    The second one is calling a function for all Cell of Figure.
    The third is creating a Cell as a copy of one in input
    and assings it to out scene special list of static cells.

    As we need to accumulate the items we also need to save the positions
    of the cells which are on bottom and to check the if they dont collide.
    For this we create a table of cells,
    and update its data on Cell becoming static,
    and check them when Figure is going donw. Like this:
    \code
        Component.onCompleted: {
            for ( var x = 0; x < scene.gridWidth; x++) {
                for ( var y = 0; y < scene.gridHeigth; y++ ) {
                    scene.cellsTable[x][y] = 0
                }
            }
        }
        ...
        function createStaticCellFrom(oldcell){
            var component = Qt.createComponent("Cell.qml");
            if (component.status == Component.Ready) {
                var cell = component.createObject(scene);
                var absX = oldcell.cellX + oldcell.parent.cellX
                var absY = oldcell.cellY + oldcell.parent.cellY
                cell.cellX = absX
                cell.cellY = absY
                scene.cellsTable[absX + absY * scene.gridWidth] = cell
                scene.cells.push(cell)
            }
        }

        function isCellDown(cell) {
            var absX = cell.cellX + cell.parent.cellX
            var absY = cell.cellY + cell.parent.cellY
            if ( scene.cellsTable[absX + (absY+1) * scene.gridWidth] != 0) {
                return true;
            }

            return ((absY + 1) == scene.gridHeigth)
        }

    \endcode

    Also after saving the latest created figure, we can move it same
    as we did with \e {figure} before.
    And we can call addFigure() when the current figure becames static.
    After playing some time we get to this situation.
    \image 05_alotOfStatic.png



 */
